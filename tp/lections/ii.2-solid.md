---
description: Как добиться хорошей архитектуры?
---

# II.2 SOLID

### 2.0 5 принципов проектирования S-O-L-I-D

### 2.1 Single-responsibility principle

Принцип единственной ответственности - существует лишь одна причина, приводящая к изменению класса.

Вместо класса можно использовать термин сущность - это зависит от уровня абстракции \(функции, классы, модули, подсистемы, ....\)

Т.е. класс должен иметь лишь одну ответственность \(группу функций\) и эта ответственность должна быть инкапсулирована в класс.

Нарушение принципа приведет к проблемам в архитектуре - при рефакторинге придется вносить изменения в несколько классов, сложнее исправлять ошибки \(хуже всего, что они могут возникать при взаимодействии нескольких классов - сложнее отлаживать, чем просто искать проблемы в одном классе\).

В чем проблема, если один класс занимается несколькими задачами?

* нарушение гибкости
* сложнее повторно использовать класс

### 2.2 Open-closed principle

Программные сущности должны быть открыты для расширения, закрыты для модификации.

Закрытость для изменения - гарантируем себе, что сущность будет сложно поломать при расширении функционала, т.е. работает гибкость и стабильность ПО.

Ошибки правим в рамках какой-либо сущности, следует не привязываться к словам и понимать, что исправление ошибок - это необходимая вещь.

Пример: логистическая компания работает с грузовиками, внезапно нужно работать еще и с самолетами. Хороший пример реализации - абстрактный класс Transport, дочерний класс Bus, добавляем Plane, общая логика транспорта зашита в абстракцию, Bus менять не нужно.архитектура открыта для расширения.

### 2.3 Liskov substitutional principle

Ребенка можно подставить вместо родителя.

Ну или объекты в программе должны быть заменяемы на объекты их подтипов без нарушения корректности работы программы.

Проблемы могут возникать не на уровне языка, а на уровне логики работы и исполнения.

Нужно думать о том, какие есть "соглашения" и "контракты" с родительским классом.

### 2.4 Interface segregation principle

Принцип разделения интерфейсом.

Много интерфейсов, специально предназначенных для разных клиентов лучше, чем один интерфейс общего назначения.

Если мы сделали большую сложную систему, может возникнуть разумное желание не открывать полностью код системы внешним пользователям \(другим продуктам или людям\) -&gt; сделаем некий интерфейс для них \(API - application public interface\). Если система большая, интерфейс тоже достаточно большой и работать с ним неудобно и неправильно.

### 2.5 Dependency inversion principle

Принцип обращения зависимости: зависимости на абстракциях, а не на реализациях.

abstract Drawer         \| ----- control1

      \|                              \| ----- control2

      \| - LinuxDrawer

      \| - WindowsDrawer

control\_\_i не зависят от drawer, а просто обращаются к нему, например через API. Если нужно что-то исправить на уровне drawer, вносим изменения только в него, 100500 контролов менять не надо.






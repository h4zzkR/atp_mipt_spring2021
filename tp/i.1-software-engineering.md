# I.1 Software engineering
# I.1 Software engineering

## План семестра

Промышленное программирование.

* Базовые понятия о проектировании ПО
* Принципы SOLID
* Работа с ошибками ПО
* Техники отладки
* Этапы развития проекта
* Основные диаграммы UML
* Методологии разработки ПО
* Антипаттерны разработки
* CL/CD
* Тестирование ПО

Две кр, оценка = 0.3  _первую + 0.7_  финальную Финальная контрольная - блокирующая, если ниже порога \(30-40%\), баллы за семестр игнорируются, происходит устный зачет. Формулу итоговой оценки см. в таблице оценок по курсу, учитываются оуценки за лекции, задания, семинары и пр.

## 1. Проектирование ПО

Проектирование ПО - выбор технологий, из каких блоков система будет состоять, как будет организовано взаимодействие этих блоков и т.д.

Как оценить, насколько хорошо спроектировали софт? Есть некие базовые критерии.

### 1.1 Критерии хорошей архитектуры

Предмет рассмотрения - промышленный софт, который используется в отвественных сценариях.

#### Эффективность системы:

* надежность: чем больше у приложения ответственность, тем выше должна быть надежность
* безопасность: в наше время это выходит на первый план
* производительность: скорость реакции на запрос, метрика количества операций за единицу времени, количество одновременно работающих в системе пользователей. Метрики снимаются в условиях, идентичных клиентским.
  * масштабируемость: 

    Возможность увеличивать производительность системы - объем данных, количество пользователей и т.п. Пример: софт под заказ, у клиента небольшой завод производства шин. Их по новому закону нужно маркировать, сделали систему, которая печатает марки для шин. Завод решили увеличить, теперь один терминал не справляется, поэтому нужно каким-то образом синхроризировать несколько терминалов. Если изначально не предполагалось этого, то будет тяжелый рефакторинг, если подумали об этом \(клиент-серверный подход\), то масштабировать будет легко. 

  * Принцип **YAGNI** - не делайте то, что никогда не понадобится. 
  * Принцип **KISS** - keep it simple, stupid

#### Гибкость системы:

* изменение текущей функциональности: насколько просто поменять логику работы софта. Пример: есть файловый редактор, сохраняет файлы на диск, хотим сохранять в облако. 
* Исправление ошибок: Чем лучше система спроектирована с т. зрения гибкости, тем легче исправлять ошибки.
* Настройка системы:
  * под пользователя
  * под разные задачи

    Могли просто все захардкодить и оставить без возможности настройки, что есть плохо. Можно предусмотреть возможность настройки параметров и т.п. и сделать систему более гибкой.

#### Расширяемость системы:

* возможность добавлять новые сущности и функции.

    Изначально проектировать систему так, чтобы внесение наиболее вероятных изменений можно было бы совершить максимально просто.

#### Еще критерии:

* масштабируемость процесса разработки: модульность архитектуры системы и независимость модулей друг от друга
* Тестируемость: поддержка качества и простота тестирования
* Возможность повторного использования: лень, реиспользование сущностей и модулей, лишняя трата времени. Коррелирует с модульностью системы.
* Сопровождаемость: у заказчика могут появится ошибки/проблемы, если не предусмотрели этого, придется каждый раз вручную ездить и разбираться, вместо, например, удаленного подключения или возможности обновления.

### Критерии неудачной архитектуры

#### Жесткость - код тяжело изменять

#### Хрупкость

* изменения нарушают другие модули \(legacy проекты\)

  **Неподвижность**

* тяжело извлечь модуль наружу \(или какую-то логику\), если этот модуль будет сильно зависим от реализации в старом месте, то будет трудно его перенести.

### High cohesion/low coupling

**High cohesion** - высокая сопряженность \(связанность\) внутри модуля, модуль сфокусирован на решении конкретной одной задачи, достигается большая гибкость

**Low coupling** - слабая связь между модулями, модули как можно больше независимы друг от друга \(слабо связаны\). Например, у каждого модуля есть свой API, по которому модули друг с другом общаются.
